// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

// Disable clippy warnings that can result in the way how parol generates code.
#![allow(clippy::enum_variant_names)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::upper_case_acronyms)]

use parol_runtime::derive_builder::Builder;
use parol_runtime::log::trace;
#[allow(unused_imports)]
use parol_runtime::parol_macros::{pop_and_reverse_item, pop_item};
use parol_runtime::parser::{ParseTreeType, UserActionsTrait};
use parol_runtime::{ParserError, Result, Token};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait SdcGrammarTrait<'t> {
    /// Semantic action for non-terminal 'TermLBracket'
    fn term_l_bracket(&mut self, _arg: &TermLBracket<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TermRBracket'
    fn term_r_bracket(&mut self, _arg: &TermRBracket<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TermLBrace'
    fn term_l_brace(&mut self, _arg: &TermLBrace<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TermRBrace'
    fn term_r_brace(&mut self, _arg: &TermRBrace<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TermStringGroup'
    fn term_string_group(&mut self, _arg: &TermStringGroup<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TermComment'
    fn term_comment(&mut self, _arg: &TermComment<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TermSemiColon'
    fn term_semi_colon(&mut self, _arg: &TermSemiColon<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TermBackslashLineBreak'
    fn term_backslash_line_break(&mut self, _arg: &TermBackslashLineBreak<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TermLineBreak'
    fn term_line_break(&mut self, _arg: &TermLineBreak<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TermWord'
    fn term_word(&mut self, _arg: &TermWord<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TermBraceGroupContent'
    fn term_brace_group_content(&mut self, _arg: &TermBraceGroupContent<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TermBraceGroup'
    fn term_brace_group(&mut self, _arg: &TermBraceGroup<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TokenEnd'
    fn token_end(&mut self, _arg: &TokenEnd<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TokenBraceGroup'
    fn token_brace_group(&mut self, _arg: &TokenBraceGroup<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TokenStringGroup'
    fn token_string_group(&mut self, _arg: &TokenStringGroup<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TokenLBracket'
    fn token_l_bracket(&mut self, _arg: &TokenLBracket<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TokenRBracket'
    fn token_r_bracket(&mut self, _arg: &TokenRBracket<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TokenWord'
    fn token_word(&mut self, _arg: &TokenWord<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Argument'
    fn argument(&mut self, _arg: &Argument<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CommandReplacement'
    fn command_replacement(&mut self, _arg: &CommandReplacement<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Command'
    fn command(&mut self, _arg: &Command<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CommandLine'
    fn command_line(&mut self, _arg: &CommandLine<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Source'
    fn source(&mut self, _arg: &Source<'t>) -> Result<()> {
        Ok(())
    }

    /// This method provides skipped language comments.
    /// If you need comments please provide your own implementation of this method.
    fn on_comment_parsed(&mut self, _token: Token<'t>) {}
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 12
///
/// `TermBraceGroupGroup: TermBraceGroup;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TermBraceGroupGroupTermBraceGroup<'t> {
    pub term_brace_group: Box<TermBraceGroup<'t>>,
}

///
/// Type derived for production 13
///
/// `TermBraceGroupGroup: TermBraceGroupContent;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TermBraceGroupGroupTermBraceGroupContent<'t> {
    pub term_brace_group_content: Box<TermBraceGroupContent<'t>>,
}

///
/// Type derived for production 14
///
/// `TokenEnd: TermLineBreak;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TokenEndTermLineBreak<'t> {
    pub term_line_break: Box<TermLineBreak<'t>>,
}

///
/// Type derived for production 15
///
/// `TokenEnd: TermSemiColon;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TokenEndTermSemiColon<'t> {
    pub term_semi_colon: Box<TermSemiColon<'t>>,
}

///
/// Type derived for production 31
///
/// `Argument: TokenWord;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArgumentTokenWord<'t> {
    pub token_word: Box<TokenWord<'t>>,
}

///
/// Type derived for production 32
///
/// `Argument: TokenStringGroup;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArgumentTokenStringGroup<'t> {
    pub token_string_group: Box<TokenStringGroup<'t>>,
}

///
/// Type derived for production 33
///
/// `Argument: TokenBraceGroup;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArgumentTokenBraceGroup<'t> {
    pub token_brace_group: Box<TokenBraceGroup<'t>>,
}

///
/// Type derived for production 34
///
/// `Argument: CommandReplacement;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArgumentCommandReplacement<'t> {
    pub command_replacement: Box<CommandReplacement<'t>>,
}

///
/// Type derived for production 42
///
/// `SourceListGroup: CommandLine;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SourceListGroupCommandLine<'t> {
    pub command_line: Box<CommandLine<'t>>,
}

///
/// Type derived for production 43
///
/// `SourceListGroup: TokenEnd;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SourceListGroupTokenEnd<'t> {
    pub token_end: Box<TokenEnd<'t>>,
}

///
/// Type derived for production 44
///
/// `SourceListGroup: TermComment;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SourceListGroupTermComment<'t> {
    pub term_comment: Box<TermComment<'t>>,
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal Argument
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Argument<'t> {
    TokenWord(ArgumentTokenWord<'t>),
    TokenStringGroup(ArgumentTokenStringGroup<'t>),
    TokenBraceGroup(ArgumentTokenBraceGroup<'t>),
    CommandReplacement(ArgumentCommandReplacement<'t>),
}

///
/// Type derived for non-terminal Command
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Command<'t> {
    pub token_word: Box<TokenWord<'t>>,
    pub command_list: Vec<CommandList<'t>>,
}

///
/// Type derived for non-terminal CommandLine
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CommandLine<'t> {
    pub command: Box<Command<'t>>,
    pub token_end: Box<TokenEnd<'t>>,
}

///
/// Type derived for non-terminal CommandList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CommandList<'t> {
    pub argument: Box<Argument<'t>>,
}

///
/// Type derived for non-terminal CommandReplacement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CommandReplacement<'t> {
    pub token_l_bracket: Box<TokenLBracket<'t>>,
    pub command: Box<Command<'t>>,
    pub token_r_bracket: Box<TokenRBracket<'t>>,
}

///
/// Type derived for non-terminal Source
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Source<'t> {
    pub source_list: Vec<SourceList<'t>>,
}

///
/// Type derived for non-terminal SourceList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SourceList<'t> {
    pub source_list_group: Box<SourceListGroup<'t>>,
}

///
/// Type derived for non-terminal SourceListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum SourceListGroup<'t> {
    CommandLine(SourceListGroupCommandLine<'t>),
    TokenEnd(SourceListGroupTokenEnd<'t>),
    TermComment(SourceListGroupTermComment<'t>),
}

///
/// Type derived for non-terminal TermBackslashLineBreak
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TermBackslashLineBreak<'t> {
    pub term_backslash_line_break: Token<'t>, /* \\(\r\n|\r|\n) */
}

///
/// Type derived for non-terminal TermBraceGroup
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TermBraceGroup<'t> {
    pub term_l_brace: Box<TermLBrace<'t>>,
    pub term_brace_group_group: Box<TermBraceGroupGroup<'t>>,
    pub term_r_brace: Box<TermRBrace<'t>>,
}

///
/// Type derived for non-terminal TermBraceGroupContent
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TermBraceGroupContent<'t> {
    pub term_brace_group_content: Token<'t>, /* [^}]* */
}

///
/// Type derived for non-terminal TermBraceGroupGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum TermBraceGroupGroup<'t> {
    TermBraceGroup(TermBraceGroupGroupTermBraceGroup<'t>),
    TermBraceGroupContent(TermBraceGroupGroupTermBraceGroupContent<'t>),
}

///
/// Type derived for non-terminal TermComment
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TermComment<'t> {
    pub term_comment: Token<'t>, /* #.*(\r\n|\r|\n|$) */
}

///
/// Type derived for non-terminal TermLBrace
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TermLBrace<'t> {
    pub term_l_brace: Token<'t>, /* { */
}

///
/// Type derived for non-terminal TermLBracket
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TermLBracket<'t> {
    pub term_l_bracket: Token<'t>, /* [ */
}

///
/// Type derived for non-terminal TermLineBreak
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TermLineBreak<'t> {
    pub term_line_break: Token<'t>, /* (\r\n|\r|\n|$) */
}

///
/// Type derived for non-terminal TermRBrace
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TermRBrace<'t> {
    pub term_r_brace: Token<'t>, /* } */
}

///
/// Type derived for non-terminal TermRBracket
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TermRBracket<'t> {
    pub term_r_bracket: Token<'t>, /* ] */
}

///
/// Type derived for non-terminal TermSemiColon
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TermSemiColon<'t> {
    pub term_semi_colon: Token<'t>, /* ; */
}

///
/// Type derived for non-terminal TermStringGroup
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TermStringGroup<'t> {
    pub term_string_group: Token<'t>, /* \u{0022}(?:\\[\u{0022}\\/bfnrt]|u[0-9a-fA-F]{4}|[^\u{0022}\\]|\\\n)*\u{0022} */
}

///
/// Type derived for non-terminal TermWord
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TermWord<'t> {
    pub term_word: Token<'t>, /* [^\s\[\]\\]+ */
}

///
/// Type derived for non-terminal TokenBraceGroup
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TokenBraceGroup<'t> {
    pub term_brace_group: Box<TermBraceGroup<'t>>,
    pub token_brace_group_opt: Option<Box<TokenBraceGroupOpt<'t>>>,
}

///
/// Type derived for non-terminal TokenBraceGroupOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TokenBraceGroupOpt<'t> {
    pub term_backslash_line_break: Box<TermBackslashLineBreak<'t>>,
}

///
/// Type derived for non-terminal TokenEnd
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum TokenEnd<'t> {
    TermLineBreak(TokenEndTermLineBreak<'t>),
    TermSemiColon(TokenEndTermSemiColon<'t>),
}

///
/// Type derived for non-terminal TokenLBracket
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TokenLBracket<'t> {
    pub term_l_bracket: Box<TermLBracket<'t>>,
    pub token_l_bracket_opt: Option<Box<TokenLBracketOpt<'t>>>,
}

///
/// Type derived for non-terminal TokenLBracketOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TokenLBracketOpt<'t> {
    pub term_backslash_line_break: Box<TermBackslashLineBreak<'t>>,
}

///
/// Type derived for non-terminal TokenRBracket
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TokenRBracket<'t> {
    pub term_r_bracket: Box<TermRBracket<'t>>,
    pub token_r_bracket_opt: Option<Box<TokenRBracketOpt<'t>>>,
}

///
/// Type derived for non-terminal TokenRBracketOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TokenRBracketOpt<'t> {
    pub term_backslash_line_break: Box<TermBackslashLineBreak<'t>>,
}

///
/// Type derived for non-terminal TokenStringGroup
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TokenStringGroup<'t> {
    pub term_string_group: Box<TermStringGroup<'t>>,
    pub token_string_group_opt: Option<Box<TokenStringGroupOpt<'t>>>,
}

///
/// Type derived for non-terminal TokenStringGroupOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TokenStringGroupOpt<'t> {
    pub term_backslash_line_break: Box<TermBackslashLineBreak<'t>>,
}

///
/// Type derived for non-terminal TokenWord
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TokenWord<'t> {
    pub term_word: Box<TermWord<'t>>,
    pub token_word_opt: Option<Box<TokenWordOpt<'t>>>,
}

///
/// Type derived for non-terminal TokenWordOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TokenWordOpt<'t> {
    pub term_backslash_line_break: Box<TermBackslashLineBreak<'t>>,
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    Argument(Argument<'t>),
    Command(Command<'t>),
    CommandLine(CommandLine<'t>),
    CommandList(Vec<CommandList<'t>>),
    CommandReplacement(CommandReplacement<'t>),
    Source(Source<'t>),
    SourceList(Vec<SourceList<'t>>),
    SourceListGroup(SourceListGroup<'t>),
    TermBackslashLineBreak(TermBackslashLineBreak<'t>),
    TermBraceGroup(TermBraceGroup<'t>),
    TermBraceGroupContent(TermBraceGroupContent<'t>),
    TermBraceGroupGroup(TermBraceGroupGroup<'t>),
    TermComment(TermComment<'t>),
    TermLBrace(TermLBrace<'t>),
    TermLBracket(TermLBracket<'t>),
    TermLineBreak(TermLineBreak<'t>),
    TermRBrace(TermRBrace<'t>),
    TermRBracket(TermRBracket<'t>),
    TermSemiColon(TermSemiColon<'t>),
    TermStringGroup(TermStringGroup<'t>),
    TermWord(TermWord<'t>),
    TokenBraceGroup(TokenBraceGroup<'t>),
    TokenBraceGroupOpt(Option<Box<TokenBraceGroupOpt<'t>>>),
    TokenEnd(TokenEnd<'t>),
    TokenLBracket(TokenLBracket<'t>),
    TokenLBracketOpt(Option<Box<TokenLBracketOpt<'t>>>),
    TokenRBracket(TokenRBracket<'t>),
    TokenRBracketOpt(Option<Box<TokenRBracketOpt<'t>>>),
    TokenStringGroup(TokenStringGroup<'t>),
    TokenStringGroupOpt(Option<Box<TokenStringGroupOpt<'t>>>),
    TokenWord(TokenWord<'t>),
    TokenWordOpt(Option<Box<TokenWordOpt<'t>>>),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct SdcGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn SdcGrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
}

///
/// The `SdcGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> SdcGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn SdcGrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        let item = self.item_stack.pop();
        if let Some(ref item) = item {
            trace!("pop     {}: {:?}", context, item);
        }
        item
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// `TermLBracket: '[';`
    ///
    #[parol_runtime::function_name::named]
    fn term_l_bracket(&mut self, term_l_bracket: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let term_l_bracket = term_l_bracket.token()?.clone();
        let term_l_bracket_built = TermLBracket { term_l_bracket };
        // Calling user action here
        self.user_grammar.term_l_bracket(&term_l_bracket_built)?;
        self.push(ASTType::TermLBracket(term_l_bracket_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// `TermRBracket: ']';`
    ///
    #[parol_runtime::function_name::named]
    fn term_r_bracket(&mut self, term_r_bracket: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let term_r_bracket = term_r_bracket.token()?.clone();
        let term_r_bracket_built = TermRBracket { term_r_bracket };
        // Calling user action here
        self.user_grammar.term_r_bracket(&term_r_bracket_built)?;
        self.push(ASTType::TermRBracket(term_r_bracket_built), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// `TermLBrace: <INITIAL, BraceGroup>'{';`
    ///
    #[parol_runtime::function_name::named]
    fn term_l_brace(&mut self, term_l_brace: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let term_l_brace = term_l_brace.token()?.clone();
        let term_l_brace_built = TermLBrace { term_l_brace };
        // Calling user action here
        self.user_grammar.term_l_brace(&term_l_brace_built)?;
        self.push(ASTType::TermLBrace(term_l_brace_built), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// `TermRBrace: <INITIAL, BraceGroup>'}';`
    ///
    #[parol_runtime::function_name::named]
    fn term_r_brace(&mut self, term_r_brace: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let term_r_brace = term_r_brace.token()?.clone();
        let term_r_brace_built = TermRBrace { term_r_brace };
        // Calling user action here
        self.user_grammar.term_r_brace(&term_r_brace_built)?;
        self.push(ASTType::TermRBrace(term_r_brace_built), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// `TermStringGroup: "\u{0022}(?:\\[\u{0022}\\/bfnrt]|u[0-9a-fA-F]{4}|[^\u{0022}\\]|\\\n)*\u{0022}";`
    ///
    #[parol_runtime::function_name::named]
    fn term_string_group(&mut self, term_string_group: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let term_string_group = term_string_group.token()?.clone();
        let term_string_group_built = TermStringGroup { term_string_group };
        // Calling user action here
        self.user_grammar
            .term_string_group(&term_string_group_built)?;
        self.push(ASTType::TermStringGroup(term_string_group_built), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// `TermComment: /#.*(\r\n|\r|\n|$)/;`
    ///
    #[parol_runtime::function_name::named]
    fn term_comment(&mut self, term_comment: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let term_comment = term_comment.token()?.clone();
        let term_comment_built = TermComment { term_comment };
        // Calling user action here
        self.user_grammar.term_comment(&term_comment_built)?;
        self.push(ASTType::TermComment(term_comment_built), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// `TermSemiColon: ';';`
    ///
    #[parol_runtime::function_name::named]
    fn term_semi_colon(&mut self, term_semi_colon: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let term_semi_colon = term_semi_colon.token()?.clone();
        let term_semi_colon_built = TermSemiColon { term_semi_colon };
        // Calling user action here
        self.user_grammar.term_semi_colon(&term_semi_colon_built)?;
        self.push(ASTType::TermSemiColon(term_semi_colon_built), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// `TermBackslashLineBreak: /\\(\r\n|\r|\n)/;`
    ///
    #[parol_runtime::function_name::named]
    fn term_backslash_line_break(
        &mut self,
        term_backslash_line_break: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let term_backslash_line_break = term_backslash_line_break.token()?.clone();
        let term_backslash_line_break_built = TermBackslashLineBreak {
            term_backslash_line_break,
        };
        // Calling user action here
        self.user_grammar
            .term_backslash_line_break(&term_backslash_line_break_built)?;
        self.push(
            ASTType::TermBackslashLineBreak(term_backslash_line_break_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// `TermLineBreak: /(\r\n|\r|\n|$)/;`
    ///
    #[parol_runtime::function_name::named]
    fn term_line_break(&mut self, term_line_break: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let term_line_break = term_line_break.token()?.clone();
        let term_line_break_built = TermLineBreak { term_line_break };
        // Calling user action here
        self.user_grammar.term_line_break(&term_line_break_built)?;
        self.push(ASTType::TermLineBreak(term_line_break_built), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// `TermWord: /[^\s\[\]\\]+/;`
    ///
    #[parol_runtime::function_name::named]
    fn term_word(&mut self, term_word: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let term_word = term_word.token()?.clone();
        let term_word_built = TermWord { term_word };
        // Calling user action here
        self.user_grammar.term_word(&term_word_built)?;
        self.push(ASTType::TermWord(term_word_built), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// `TermBraceGroupContent: <BraceGroup>/[^}]*/;`
    ///
    #[parol_runtime::function_name::named]
    fn term_brace_group_content(
        &mut self,
        term_brace_group_content: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let term_brace_group_content = term_brace_group_content.token()?.clone();
        let term_brace_group_content_built = TermBraceGroupContent {
            term_brace_group_content,
        };
        // Calling user action here
        self.user_grammar
            .term_brace_group_content(&term_brace_group_content_built)?;
        self.push(
            ASTType::TermBraceGroupContent(term_brace_group_content_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// `TermBraceGroup: TermLBrace %push(BraceGroup) TermBraceGroupGroup TermRBrace %pop();`
    ///
    #[parol_runtime::function_name::named]
    fn term_brace_group(
        &mut self,
        _term_l_brace: &ParseTreeType<'t>,
        _term_brace_group_group: &ParseTreeType<'t>,
        _term_r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let term_r_brace = pop_item!(self, term_r_brace, TermRBrace, context);
        let term_brace_group_group =
            pop_item!(self, term_brace_group_group, TermBraceGroupGroup, context);
        let term_l_brace = pop_item!(self, term_l_brace, TermLBrace, context);
        let term_brace_group_built = TermBraceGroup {
            term_l_brace: Box::new(term_l_brace),
            term_brace_group_group: Box::new(term_brace_group_group),
            term_r_brace: Box::new(term_r_brace),
        };
        // Calling user action here
        self.user_grammar
            .term_brace_group(&term_brace_group_built)?;
        self.push(ASTType::TermBraceGroup(term_brace_group_built), context);
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// `TermBraceGroupGroup: TermBraceGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn term_brace_group_group_0(&mut self, _term_brace_group: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let term_brace_group = pop_item!(self, term_brace_group, TermBraceGroup, context);
        let term_brace_group_group_0_built = TermBraceGroupGroupTermBraceGroup {
            term_brace_group: Box::new(term_brace_group),
        };
        let term_brace_group_group_0_built =
            TermBraceGroupGroup::TermBraceGroup(term_brace_group_group_0_built);
        self.push(
            ASTType::TermBraceGroupGroup(term_brace_group_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// `TermBraceGroupGroup: TermBraceGroupContent;`
    ///
    #[parol_runtime::function_name::named]
    fn term_brace_group_group_1(
        &mut self,
        _term_brace_group_content: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let term_brace_group_content = pop_item!(
            self,
            term_brace_group_content,
            TermBraceGroupContent,
            context
        );
        let term_brace_group_group_1_built = TermBraceGroupGroupTermBraceGroupContent {
            term_brace_group_content: Box::new(term_brace_group_content),
        };
        let term_brace_group_group_1_built =
            TermBraceGroupGroup::TermBraceGroupContent(term_brace_group_group_1_built);
        self.push(
            ASTType::TermBraceGroupGroup(term_brace_group_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// `TokenEnd: TermLineBreak;`
    ///
    #[parol_runtime::function_name::named]
    fn token_end_0(&mut self, _term_line_break: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let term_line_break = pop_item!(self, term_line_break, TermLineBreak, context);
        let token_end_0_built = TokenEndTermLineBreak {
            term_line_break: Box::new(term_line_break),
        };
        let token_end_0_built = TokenEnd::TermLineBreak(token_end_0_built);
        // Calling user action here
        self.user_grammar.token_end(&token_end_0_built)?;
        self.push(ASTType::TokenEnd(token_end_0_built), context);
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// `TokenEnd: TermSemiColon;`
    ///
    #[parol_runtime::function_name::named]
    fn token_end_1(&mut self, _term_semi_colon: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let term_semi_colon = pop_item!(self, term_semi_colon, TermSemiColon, context);
        let token_end_1_built = TokenEndTermSemiColon {
            term_semi_colon: Box::new(term_semi_colon),
        };
        let token_end_1_built = TokenEnd::TermSemiColon(token_end_1_built);
        // Calling user action here
        self.user_grammar.token_end(&token_end_1_built)?;
        self.push(ASTType::TokenEnd(token_end_1_built), context);
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// `TokenBraceGroup: TermBraceGroup TokenBraceGroupOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn token_brace_group(
        &mut self,
        _term_brace_group: &ParseTreeType<'t>,
        _token_brace_group_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let token_brace_group_opt =
            pop_item!(self, token_brace_group_opt, TokenBraceGroupOpt, context);
        let term_brace_group = pop_item!(self, term_brace_group, TermBraceGroup, context);
        let token_brace_group_built = TokenBraceGroup {
            term_brace_group: Box::new(term_brace_group),
            token_brace_group_opt,
        };
        // Calling user action here
        self.user_grammar
            .token_brace_group(&token_brace_group_built)?;
        self.push(ASTType::TokenBraceGroup(token_brace_group_built), context);
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// `TokenBraceGroupOpt /* Option<T>::Some */: TermBackslashLineBreak;`
    ///
    #[parol_runtime::function_name::named]
    fn token_brace_group_opt_0(
        &mut self,
        _term_backslash_line_break: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let term_backslash_line_break = pop_item!(
            self,
            term_backslash_line_break,
            TermBackslashLineBreak,
            context
        );
        let token_brace_group_opt_0_built = TokenBraceGroupOpt {
            term_backslash_line_break: Box::new(term_backslash_line_break),
        };
        self.push(
            ASTType::TokenBraceGroupOpt(Some(Box::new(token_brace_group_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// `TokenBraceGroupOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn token_brace_group_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TokenBraceGroupOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// `TokenStringGroup: TermStringGroup TokenStringGroupOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn token_string_group(
        &mut self,
        _term_string_group: &ParseTreeType<'t>,
        _token_string_group_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let token_string_group_opt =
            pop_item!(self, token_string_group_opt, TokenStringGroupOpt, context);
        let term_string_group = pop_item!(self, term_string_group, TermStringGroup, context);
        let token_string_group_built = TokenStringGroup {
            term_string_group: Box::new(term_string_group),
            token_string_group_opt,
        };
        // Calling user action here
        self.user_grammar
            .token_string_group(&token_string_group_built)?;
        self.push(ASTType::TokenStringGroup(token_string_group_built), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// `TokenStringGroupOpt /* Option<T>::Some */: TermBackslashLineBreak;`
    ///
    #[parol_runtime::function_name::named]
    fn token_string_group_opt_0(
        &mut self,
        _term_backslash_line_break: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let term_backslash_line_break = pop_item!(
            self,
            term_backslash_line_break,
            TermBackslashLineBreak,
            context
        );
        let token_string_group_opt_0_built = TokenStringGroupOpt {
            term_backslash_line_break: Box::new(term_backslash_line_break),
        };
        self.push(
            ASTType::TokenStringGroupOpt(Some(Box::new(token_string_group_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// `TokenStringGroupOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn token_string_group_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TokenStringGroupOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// `TokenLBracket: TermLBracket TokenLBracketOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn token_l_bracket(
        &mut self,
        _term_l_bracket: &ParseTreeType<'t>,
        _token_l_bracket_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let token_l_bracket_opt = pop_item!(self, token_l_bracket_opt, TokenLBracketOpt, context);
        let term_l_bracket = pop_item!(self, term_l_bracket, TermLBracket, context);
        let token_l_bracket_built = TokenLBracket {
            term_l_bracket: Box::new(term_l_bracket),
            token_l_bracket_opt,
        };
        // Calling user action here
        self.user_grammar.token_l_bracket(&token_l_bracket_built)?;
        self.push(ASTType::TokenLBracket(token_l_bracket_built), context);
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// `TokenLBracketOpt /* Option<T>::Some */: TermBackslashLineBreak;`
    ///
    #[parol_runtime::function_name::named]
    fn token_l_bracket_opt_0(
        &mut self,
        _term_backslash_line_break: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let term_backslash_line_break = pop_item!(
            self,
            term_backslash_line_break,
            TermBackslashLineBreak,
            context
        );
        let token_l_bracket_opt_0_built = TokenLBracketOpt {
            term_backslash_line_break: Box::new(term_backslash_line_break),
        };
        self.push(
            ASTType::TokenLBracketOpt(Some(Box::new(token_l_bracket_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// `TokenLBracketOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn token_l_bracket_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TokenLBracketOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// `TokenRBracket: TermRBracket TokenRBracketOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn token_r_bracket(
        &mut self,
        _term_r_bracket: &ParseTreeType<'t>,
        _token_r_bracket_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let token_r_bracket_opt = pop_item!(self, token_r_bracket_opt, TokenRBracketOpt, context);
        let term_r_bracket = pop_item!(self, term_r_bracket, TermRBracket, context);
        let token_r_bracket_built = TokenRBracket {
            term_r_bracket: Box::new(term_r_bracket),
            token_r_bracket_opt,
        };
        // Calling user action here
        self.user_grammar.token_r_bracket(&token_r_bracket_built)?;
        self.push(ASTType::TokenRBracket(token_r_bracket_built), context);
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// `TokenRBracketOpt /* Option<T>::Some */: TermBackslashLineBreak;`
    ///
    #[parol_runtime::function_name::named]
    fn token_r_bracket_opt_0(
        &mut self,
        _term_backslash_line_break: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let term_backslash_line_break = pop_item!(
            self,
            term_backslash_line_break,
            TermBackslashLineBreak,
            context
        );
        let token_r_bracket_opt_0_built = TokenRBracketOpt {
            term_backslash_line_break: Box::new(term_backslash_line_break),
        };
        self.push(
            ASTType::TokenRBracketOpt(Some(Box::new(token_r_bracket_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// `TokenRBracketOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn token_r_bracket_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TokenRBracketOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// `TokenWord: TermWord TokenWordOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn token_word(
        &mut self,
        _term_word: &ParseTreeType<'t>,
        _token_word_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let token_word_opt = pop_item!(self, token_word_opt, TokenWordOpt, context);
        let term_word = pop_item!(self, term_word, TermWord, context);
        let token_word_built = TokenWord {
            term_word: Box::new(term_word),
            token_word_opt,
        };
        // Calling user action here
        self.user_grammar.token_word(&token_word_built)?;
        self.push(ASTType::TokenWord(token_word_built), context);
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// `TokenWordOpt /* Option<T>::Some */: TermBackslashLineBreak;`
    ///
    #[parol_runtime::function_name::named]
    fn token_word_opt_0(&mut self, _term_backslash_line_break: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let term_backslash_line_break = pop_item!(
            self,
            term_backslash_line_break,
            TermBackslashLineBreak,
            context
        );
        let token_word_opt_0_built = TokenWordOpt {
            term_backslash_line_break: Box::new(term_backslash_line_break),
        };
        self.push(
            ASTType::TokenWordOpt(Some(Box::new(token_word_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// `TokenWordOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn token_word_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TokenWordOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// `Argument: TokenWord;`
    ///
    #[parol_runtime::function_name::named]
    fn argument_0(&mut self, _token_word: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let token_word = pop_item!(self, token_word, TokenWord, context);
        let argument_0_built = ArgumentTokenWord {
            token_word: Box::new(token_word),
        };
        let argument_0_built = Argument::TokenWord(argument_0_built);
        // Calling user action here
        self.user_grammar.argument(&argument_0_built)?;
        self.push(ASTType::Argument(argument_0_built), context);
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// `Argument: TokenStringGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn argument_1(&mut self, _token_string_group: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let token_string_group = pop_item!(self, token_string_group, TokenStringGroup, context);
        let argument_1_built = ArgumentTokenStringGroup {
            token_string_group: Box::new(token_string_group),
        };
        let argument_1_built = Argument::TokenStringGroup(argument_1_built);
        // Calling user action here
        self.user_grammar.argument(&argument_1_built)?;
        self.push(ASTType::Argument(argument_1_built), context);
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// `Argument: TokenBraceGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn argument_2(&mut self, _token_brace_group: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let token_brace_group = pop_item!(self, token_brace_group, TokenBraceGroup, context);
        let argument_2_built = ArgumentTokenBraceGroup {
            token_brace_group: Box::new(token_brace_group),
        };
        let argument_2_built = Argument::TokenBraceGroup(argument_2_built);
        // Calling user action here
        self.user_grammar.argument(&argument_2_built)?;
        self.push(ASTType::Argument(argument_2_built), context);
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// `Argument: CommandReplacement;`
    ///
    #[parol_runtime::function_name::named]
    fn argument_3(&mut self, _command_replacement: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let command_replacement = pop_item!(self, command_replacement, CommandReplacement, context);
        let argument_3_built = ArgumentCommandReplacement {
            command_replacement: Box::new(command_replacement),
        };
        let argument_3_built = Argument::CommandReplacement(argument_3_built);
        // Calling user action here
        self.user_grammar.argument(&argument_3_built)?;
        self.push(ASTType::Argument(argument_3_built), context);
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// `CommandReplacement: TokenLBracket Command TokenRBracket;`
    ///
    #[parol_runtime::function_name::named]
    fn command_replacement(
        &mut self,
        _token_l_bracket: &ParseTreeType<'t>,
        _command: &ParseTreeType<'t>,
        _token_r_bracket: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let token_r_bracket = pop_item!(self, token_r_bracket, TokenRBracket, context);
        let command = pop_item!(self, command, Command, context);
        let token_l_bracket = pop_item!(self, token_l_bracket, TokenLBracket, context);
        let command_replacement_built = CommandReplacement {
            token_l_bracket: Box::new(token_l_bracket),
            command: Box::new(command),
            token_r_bracket: Box::new(token_r_bracket),
        };
        // Calling user action here
        self.user_grammar
            .command_replacement(&command_replacement_built)?;
        self.push(
            ASTType::CommandReplacement(command_replacement_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// `Command: TokenWord CommandList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn command(
        &mut self,
        _token_word: &ParseTreeType<'t>,
        _command_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let command_list = pop_and_reverse_item!(self, command_list, CommandList, context);
        let token_word = pop_item!(self, token_word, TokenWord, context);
        let command_built = Command {
            token_word: Box::new(token_word),
            command_list,
        };
        // Calling user action here
        self.user_grammar.command(&command_built)?;
        self.push(ASTType::Command(command_built), context);
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// `CommandList /* Vec<T>::Push */: Argument CommandList;`
    ///
    #[parol_runtime::function_name::named]
    fn command_list_0(
        &mut self,
        _argument: &ParseTreeType<'t>,
        _command_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut command_list = pop_item!(self, command_list, CommandList, context);
        let argument = pop_item!(self, argument, Argument, context);
        let command_list_0_built = CommandList {
            argument: Box::new(argument),
        };
        // Add an element to the vector
        command_list.push(command_list_0_built);
        self.push(ASTType::CommandList(command_list), context);
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// `CommandList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn command_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let command_list_1_built = Vec::new();
        self.push(ASTType::CommandList(command_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// `CommandLine: Command TokenEnd;`
    ///
    #[parol_runtime::function_name::named]
    fn command_line(
        &mut self,
        _command: &ParseTreeType<'t>,
        _token_end: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let token_end = pop_item!(self, token_end, TokenEnd, context);
        let command = pop_item!(self, command, Command, context);
        let command_line_built = CommandLine {
            command: Box::new(command),
            token_end: Box::new(token_end),
        };
        // Calling user action here
        self.user_grammar.command_line(&command_line_built)?;
        self.push(ASTType::CommandLine(command_line_built), context);
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// `Source: SourceList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn source(&mut self, _source_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let source_list = pop_and_reverse_item!(self, source_list, SourceList, context);
        let source_built = Source { source_list };
        // Calling user action here
        self.user_grammar.source(&source_built)?;
        self.push(ASTType::Source(source_built), context);
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// `SourceList /* Vec<T>::Push */: SourceListGroup SourceList;`
    ///
    #[parol_runtime::function_name::named]
    fn source_list_0(
        &mut self,
        _source_list_group: &ParseTreeType<'t>,
        _source_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut source_list = pop_item!(self, source_list, SourceList, context);
        let source_list_group = pop_item!(self, source_list_group, SourceListGroup, context);
        let source_list_0_built = SourceList {
            source_list_group: Box::new(source_list_group),
        };
        // Add an element to the vector
        source_list.push(source_list_0_built);
        self.push(ASTType::SourceList(source_list), context);
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// `SourceListGroup: CommandLine;`
    ///
    #[parol_runtime::function_name::named]
    fn source_list_group_0(&mut self, _command_line: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let command_line = pop_item!(self, command_line, CommandLine, context);
        let source_list_group_0_built = SourceListGroupCommandLine {
            command_line: Box::new(command_line),
        };
        let source_list_group_0_built = SourceListGroup::CommandLine(source_list_group_0_built);
        self.push(ASTType::SourceListGroup(source_list_group_0_built), context);
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// `SourceListGroup: TokenEnd;`
    ///
    #[parol_runtime::function_name::named]
    fn source_list_group_1(&mut self, _token_end: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let token_end = pop_item!(self, token_end, TokenEnd, context);
        let source_list_group_1_built = SourceListGroupTokenEnd {
            token_end: Box::new(token_end),
        };
        let source_list_group_1_built = SourceListGroup::TokenEnd(source_list_group_1_built);
        self.push(ASTType::SourceListGroup(source_list_group_1_built), context);
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// `SourceListGroup: TermComment;`
    ///
    #[parol_runtime::function_name::named]
    fn source_list_group_2(&mut self, _term_comment: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let term_comment = pop_item!(self, term_comment, TermComment, context);
        let source_list_group_2_built = SourceListGroupTermComment {
            term_comment: Box::new(term_comment),
        };
        let source_list_group_2_built = SourceListGroup::TermComment(source_list_group_2_built);
        self.push(ASTType::SourceListGroup(source_list_group_2_built), context);
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// `SourceList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn source_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let source_list_1_built = Vec::new();
        self.push(ASTType::SourceList(source_list_1_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for SdcGrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item SdcGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeType<'t>],
    ) -> Result<()> {
        match prod_num {
            0 => self.term_l_bracket(&children[0]),
            1 => self.term_r_bracket(&children[0]),
            2 => self.term_l_brace(&children[0]),
            3 => self.term_r_brace(&children[0]),
            4 => self.term_string_group(&children[0]),
            5 => self.term_comment(&children[0]),
            6 => self.term_semi_colon(&children[0]),
            7 => self.term_backslash_line_break(&children[0]),
            8 => self.term_line_break(&children[0]),
            9 => self.term_word(&children[0]),
            10 => self.term_brace_group_content(&children[0]),
            11 => self.term_brace_group(&children[0], &children[1], &children[2]),
            12 => self.term_brace_group_group_0(&children[0]),
            13 => self.term_brace_group_group_1(&children[0]),
            14 => self.token_end_0(&children[0]),
            15 => self.token_end_1(&children[0]),
            16 => self.token_brace_group(&children[0], &children[1]),
            17 => self.token_brace_group_opt_0(&children[0]),
            18 => self.token_brace_group_opt_1(),
            19 => self.token_string_group(&children[0], &children[1]),
            20 => self.token_string_group_opt_0(&children[0]),
            21 => self.token_string_group_opt_1(),
            22 => self.token_l_bracket(&children[0], &children[1]),
            23 => self.token_l_bracket_opt_0(&children[0]),
            24 => self.token_l_bracket_opt_1(),
            25 => self.token_r_bracket(&children[0], &children[1]),
            26 => self.token_r_bracket_opt_0(&children[0]),
            27 => self.token_r_bracket_opt_1(),
            28 => self.token_word(&children[0], &children[1]),
            29 => self.token_word_opt_0(&children[0]),
            30 => self.token_word_opt_1(),
            31 => self.argument_0(&children[0]),
            32 => self.argument_1(&children[0]),
            33 => self.argument_2(&children[0]),
            34 => self.argument_3(&children[0]),
            35 => self.command_replacement(&children[0], &children[1], &children[2]),
            36 => self.command(&children[0], &children[1]),
            37 => self.command_list_0(&children[0], &children[1]),
            38 => self.command_list_1(),
            39 => self.command_line(&children[0], &children[1]),
            40 => self.source(&children[0]),
            41 => self.source_list_0(&children[0], &children[1]),
            42 => self.source_list_group_0(&children[0]),
            43 => self.source_list_group_1(&children[0]),
            44 => self.source_list_group_2(&children[0]),
            45 => self.source_list_1(),
            _ => Err(ParserError::InternalError(format!(
                "Unhandled production number: {}",
                prod_num
            ))
            .into()),
        }
    }

    fn on_comment_parsed(&mut self, token: Token<'t>) {
        self.user_grammar.on_comment_parsed(token)
    }
}
